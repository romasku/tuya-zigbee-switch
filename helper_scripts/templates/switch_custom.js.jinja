const {
    numeric,
    enumLookup,
    deviceEndpoints,
    onOff,
    text,
    binary,
    windowCovering,
    deviceAddCustomCluster,
} = require("zigbee-herdsman-converters/lib/modernExtend");
const {assertString} = require("zigbee-herdsman-converters/lib/utils");
const reporting = require("zigbee-herdsman-converters/lib/reporting");
const constants = require("zigbee-herdsman-converters/lib/constants");
const Zcl = require('zigbee-herdsman').Zcl;
{% if z2m_v1 %}
const ota = require("zigbee-herdsman-converters/lib/ota");
{% endif%}

/********************************************************************
  This file (`switch_custom.js`) is generated. 
  
  You can edit it for testing, but for PRs please use:
  - `device_db.yaml`                - add or edit devices
  - `switch_custom.md.jinja`        - update the template
  - `make_z2m_custom_converters.py` - update generation script

  Generate with: `make converters`
********************************************************************/

const romasku = {
    switchAction: (name, endpointName) =>
        enumLookup({
            name,
            endpointName,
            lookup: { on_off: 0, off_on: 1, toggle_simple: 2, toggle_smart_sync: 3, toggle_smart_opposite: 4 },
            cluster: "genOnOffSwitchCfg",
            attribute: {ID: 0x0010, type: 0x30, required: true, write: true, min: 0, max: 4}, // Enum8
            description: `Select how switch should work:
            - on_off: When switch physically moved to position 1 it always generates ON command, and when moved to position 2 it generates OFF command
            - off_on: Same as on_off, but positions are swapped
            - toggle_simple: Any press of physical switch will TOGGLE the relay and send TOGGLE command to binds
            - toggle_smart_sync: Any press of physical switch will TOGGLE the relay and send corresponding ON/OFF command to keep binds in sync with relay
            - toggle_smart_opposite: Any press of physical switch: TOGGLE the relay and send corresponding ON/OFF command to keep binds in the state opposite to the relay`,
            entityCategory: "config",
        }),
    switchMode: (name, endpointName) =>
        enumLookup({
            name,
            endpointName,
            lookup: { toggle: 0, momentary: 1, momentary_nc: 2 },
            cluster: "genOnOffSwitchCfg",
            attribute: { ID: 0xff00, type: 0x30 }, // Enum8
            description: "Select the type of switch connected to the device",
            entityCategory: "config",
        }),
    relayMode: (name, endpointName) =>
        enumLookup({
            name,
            endpointName,
            lookup: { detached: 0, press_start: 1, short_press: 3, long_press: 2},
            cluster: "genOnOffSwitchCfg",
            attribute: { ID: 0xff01, type: 0x30 }, // Enum8
            description: "When to turn on/off internal relay",
            entityCategory: "config",
        }),
    relayIndex: (name, endpointName, relay_cnt) =>
        enumLookup({
            name,
            endpointName,
            lookup: Object.fromEntries(
                Array.from({ length: relay_cnt || 2 }, (_, i) => [`relay_${i + 1}`, i + 1])
            ),
            cluster: "genOnOffSwitchCfg",
            attribute: { ID: 0xff02, type: 0x20 }, // uint8
            description: "Which internal relay it should trigger",
            entityCategory: "config",
        }),
    bindedMode: (name, endpointName) =>
        enumLookup({
            name,
            endpointName,
            lookup: { press_start: 1, short_press: 3, long_press: 2},
            cluster: "genOnOffSwitchCfg",
            attribute: { ID: 0xff05, type: 0x30 }, // Enum8
            description: "When turn on/off binded device",
            entityCategory: "config",
        }),
    longPressDuration: (name, endpointName) =>
        numeric({
            name,
            endpointNames: [endpointName],
            cluster: "genOnOffSwitchCfg",
            attribute: { ID: 0xff03, type: 0x21 }, // uint16
            description: "What duration is considerd to be long press",
            valueMin: 0,
            valueMax: 5000,
            entityCategory: "config",
        }),
    levelMoveRate: (name, endpointName) =>
        numeric({
            name,
            endpointNames: [endpointName],
            cluster: "genOnOffSwitchCfg",
            attribute: { ID: 0xff04, type: 0x20 }, // uint8
            description: "Level (dim) move rate in steps per ms",
            valueMin: 1,
            valueMax: 255,
            entityCategory: "config",
        }),
    pressAction: (name, endpointName) =>
        enumLookup({
            name,
            endpointName,
            access: "STATE_GET",
            lookup: { released: 0, press: 1, long_press: 2, position_on: 3, position_off: 4 },
            cluster: "genMultistateInput",
            attribute: "presentValue",
            description: "Action of the switch: 'released' or 'press' or 'long_press'",
            entityCategory: "diagnostic",
        }),
    relayIndicatorMode: (name, endpointName) =>
        enumLookup({
            name,
            endpointName,
            lookup: { same: 0, opposite: 1, manual: 2 },
            cluster: "genOnOff",
            attribute: { ID: 0xff01, type: 0x30 }, // Enum8
            description: "Mode for the relay indicator LED",
            entityCategory: "config",
        }),
    relayIndicator: (name, endpointName) =>
        binary({
            name,
            endpointName,
            valueOn: ["ON", 1],
            valueOff: ["OFF", 0],
            cluster: "genOnOff",
            attribute: {ID: 0xff02, type: 0x10},  // Boolean
            description: "State of the relay indicator LED",
            access: "ALL",
            entityCategory: "config",
        }),
    networkIndicator: (name, endpointName) =>
        binary({
            name,
            endpointName,
            valueOn: ["ON", 1],
            valueOff: ["OFF", 0],
            cluster: "genBasic",
            attribute: {ID: 0xff01, type: 0x10},  // Boolean
            description: "State of the network indicator LED",
            access: "ALL",
            entityCategory: "config",
        }),
    deviceConfig: (name, endpointName) =>
        text({
            name,
            endpointName,
            access: "ALL",
            cluster: "genBasic",
            attribute:  { ID: 0xff00, type: 0x44 }, // long str
            description: "Current configuration of the device",
            zigbeeCommandOptions: {timeout: 30_000},
            validate: (value) => {
                assertString(value);
                
                const validatePin = (pin) => {
                    const validPins = [
                        "A0", "A1", "A2", "A3", "A4", "A5", "A6","A7",
                        "B0", "B1", "B2", "B3", "B4", "B5", "B6","B7",
                        "C0", "C1", "C2", "C3", "C4", "C5", "C6","C7",
                        "D0", "D1", "D2", "D3", "D4", "D5", "D6","D7",
                        "E0", "E1", "E2", "E3",
                    ];
                    if (!validPins.includes(pin)) throw new Error(`Pin ${pin} is invalid`);
                }

                if (value.length > 256) throw new Error('Length of config is greater than 256');
                if (!value.endsWith(';')) throw new Error('Should end with ;');
                const parts = value.slice(0, -1).split(';');  // Drop last ;
                if (parts.length < 2) throw new Error("Model and/or manufacturer missing");
                for (const part of parts.slice(2)) {
                    if (part == 'SLP') {
                        continue;   
                    } if (part[0] == 'B' || part[0] == 'S') {
                        validatePin(part.slice(1,3));
                        if (!["u", "U", "d", "f"].includes(part[3])) {
                            throw new Error(`Pull up down ${part[3]} is invalid. Valid options are u, U, d, f`);
                        } 
                    } else if (part[0] == 'X') {
                        validatePin(part.slice(1,3));
                        validatePin(part.slice(3,5));
                        if (!["u", "U", "d", "f"].includes(part[5])) {
                            throw new Error(`Pull up down ${part[5]} is invalid. Valid options are u, U, d, f`);
                        }
                    } else if (part[0] == 'C') {
                        validatePin(part.slice(1,3));
                        validatePin(part.slice(3,5));
                    } else if (part[0] == 'L' || part[0] == 'R' || part[0] == 'I') {
                        validatePin(part.slice(1,3));
                    } else if(part[0] == 'M') {
                        ;
                    } else if(part[0] == 'i') {
                        ; // TODO: write validation
                    } else {
                        throw new Error(`Invalid entry ${part}. Should start with one of B, R, L, S, I, X, C`);
                    }
                }
            },
            entityCategory: "config",
        }),
    coverSwitchPressAction: (name, endpointName) =>
        enumLookup({
            name,
            endpointName,
            access: "STATE_GET",
            lookup: { 
                released: 0, 
                open: 1, 
                close: 2,
                stop: 3,
                long_open: 4,
                long_close: 5
            },
            cluster: "genMultistateInput",
            attribute: "presentValue",
            description: "Cover switch button press action",
            entityCategory: "diagnostic"
        }),
    coverSwitchType: (name, endpointName) =>
        enumLookup({
            name,
            endpointName,
            lookup: { toggle: 0, momentary: 1 },
            cluster: "manuSpecificTuyaCoverSwitchConfig",
            attribute: "switchType",
            description: "Type of cover switch: toggle (rocker) or momentary (push button)",
            entityCategory: "config",
        }),
    coverSwitchCoverIndex: (name, endpointName, output_cnt) =>
        enumLookup({
            name,
            endpointName,
            lookup: Object.fromEntries([
                ['detached', 0],
                ...Array.from({ length: output_cnt || 2 }, (_, i) => [`cover_${i + 1}`, i + 1])
            ]),
            cluster: "manuSpecificTuyaCoverSwitchConfig",
            attribute: "coverIndex",
            description: "Which cover to control locally (detached = no local control)",
            entityCategory: "config",
        }),
    coverSwitchInvert: (name, endpointName) =>
        binary({
            name,
            endpointName,
            valueOn: ["ON", 1],
            valueOff: ["OFF", 0],
            cluster: "manuSpecificTuyaCoverSwitchConfig",
            attribute: "reversal",
            description: "Inverts UP/DOWN direction for inputs",
            access: "ALL",
            entityCategory: "config",
        }),
    coverSwitchLocalMode: (name, endpointName) =>
        enumLookup({
            name,
            endpointName,
            lookup: { immediate: 0, short_press: 1, long_press: 2, hybrid: 3 },
            cluster: "manuSpecificTuyaCoverSwitchConfig",
            attribute: "localMode",
            description: "When to trigger local cover: immediate (start/stop on press), short_press (trigger on release), long_press (trigger after long press duration), hybrid (trigger on release or continuous movement while held). Note: only affects momentary switches",
            entityCategory: "config",
        }),
    coverSwitchBindedMode: (name, endpointName) =>
        enumLookup({
            name,
            endpointName,
            lookup: { immediate: 0, short_press: 1, long_press: 2, hybrid: 3 },
            cluster: "manuSpecificTuyaCoverSwitchConfig",
            attribute: "bindedMode",
            description: "When to send commands to bound devices: immediate (start/stop on press), short_press (trigger on release), long_press (trigger after long press duration), hybrid (trigger on release or continuous movement while held). Note: only affects momentary switches",
            entityCategory: "config",
        }),
    coverSwitchLongPressDuration: (name, endpointName) =>
        numeric({
            name,
            endpointNames: [endpointName],
            cluster: "manuSpecificTuyaCoverSwitchConfig",
            attribute: "longPressDuration",
            description: "Threshold in milliseconds to distinguish short press from long press",
            valueMin: 0,
            valueMax: 5000,
            entityCategory: "config",
        }),
    coverMoving: (name, endpointName) =>
        enumLookup({
            name,
            endpointName,
            access: "STATE_GET",
            lookup: {
                stopped: 0,
                opening: 1,
                closing: 2
            },
            cluster: "closuresWindowCovering",
            attribute: "moving",
            description: "Cover movement status",
            entityCategory: "diagnostic",
        }),
    coverMotorReversal: (name, endpointName) =>
        binary({
            name,
            endpointName,
            valueOn: [true, 1],
            valueOff: [false, 0],
            cluster: "closuresWindowCovering",
            attribute: "motorReversal",
            description: "Reverse motor direction (swap OPEN/CLOSE relays)",
            entityCategory: "config",
        }),
};

const definitions = [
{% for device in devices %}
    {
        zigbeeModel: [
        {% for zb_model in device.zb_models %}
            "{{zb_model}}",
        {% endfor %}
        ],
        model: "{{device.model}}",
        vendor: "Tuya-custom",
        description: "Custom switch (https://github.com/romasku/tuya-zigbee-switch)",
        extend: [
            {% if device.coverSwitchNames %}
            deviceAddCustomCluster("manuSpecificTuyaCoverSwitchConfig", {
                ID: 0xFC01,
                manufacturerCode: 0x125D,
                attributes: {
                    switchType: {ID: 0x0000, type: Zcl.DataType.ENUM8},
                    coverIndex: {ID: 0x0001, type: Zcl.DataType.UINT8},
                    reversal: {ID: 0x0002, type: Zcl.DataType.BOOLEAN},
                    localMode: {ID: 0x0003, type: Zcl.DataType.ENUM8},
                    bindedMode: {ID: 0x0004, type: Zcl.DataType.ENUM8},
                    longPressDuration: {ID: 0x0005, type: Zcl.DataType.UINT16},
                },
                commands: {},
                commandsResponse: {},
            }),
            {% endif %}
            {% if device.coverNames %}
            deviceAddCustomCluster("closuresWindowCovering", {
                ID: 0x0102,
                attributes: {
                    moving: {ID: 0xff00, type: Zcl.DataType.ENUM8},
                    motorReversal: {ID: 0xff01, type: Zcl.DataType.BOOLEAN},
                },
            }),
            {% endif %}
            deviceEndpoints({ endpoints: {
                {%- for switchName in device.switchNames -%}
                    "{{switchName}}": {{loop.index}},{{" "}}
                {%- endfor -%}
                {%- for relayName in device.relayNames -%}
                    "{{relayName}}": {{loop.index  + (device.switchNames | length)}},{{" "}}
                {%- endfor -%}
                {%- for coverSwitchName in device.coverSwitchNames -%}
                    "{{coverSwitchName}}": {{loop.index + (device.switchNames | length) + (device.relayNames | length)}},{{" "}}
                {%- endfor -%}
                {%- for coverName in device.coverNames -%}
                    "{{coverName}}": {{loop.index + (device.switchNames | length) + (device.relayNames | length) + (device.coverSwitchNames | length)}},{{" "}}
                {%- endfor -%}
            } }),
            {% set first_endpoint = device.switchNames[0] if device.switchNames else (device.relayNames[0] if device.relayNames else (device.coverSwitchNames[0] if device.coverSwitchNames else device.coverNames[0])) %}
            romasku.deviceConfig("device_config", "{{first_endpoint}}"),
            {% if device.has_dedicated_net_led %}
            romasku.networkIndicator("network_led", "{{first_endpoint}}"),
            {% endif%}
            {% if device.relayNames %}
            onOff({ endpointNames: {{device.relayNames | tojson }} }),
            {% endif %}
            {% for switchName in device.switchNames %}
            romasku.pressAction("{{switchName}}_press_action", "{{switchName}}"),
            romasku.switchMode("{{switchName}}_mode", "{{switchName}}"),
            romasku.switchAction("{{switchName}}_action_mode", "{{switchName}}"),
            romasku.relayMode("{{switchName}}_relay_mode", "{{switchName}}"),
            romasku.relayIndex("{{switchName}}_relay_index", "{{switchName}}", {{device.relayNames | length}}),
            romasku.bindedMode("{{switchName}}_binded_mode", "{{switchName}}"),
            romasku.longPressDuration("{{switchName}}_long_press_duration", "{{switchName}}"),
            romasku.levelMoveRate("{{switchName}}_level_move_rate", "{{switchName}}"),
            {% endfor %}
            {% for relayName in device.relayIndicatorNames %}
            romasku.relayIndicatorMode("{{relayName}}_indicator_mode", "{{relayName}}"),
            romasku.relayIndicator("{{relayName}}_indicator", "{{relayName}}"),
            {% endfor %}
            {% for coverName in device.coverNames %}
            windowCovering({ 
                controls: ["lift"],
                coverInverted: true,
                configureReporting: false,
                endpointNames: ["{{coverName}}"]
            }),
            romasku.coverMoving("{{coverName}}_moving", "{{coverName}}"),
            romasku.coverMotorReversal("{{coverName}}_motor_reversal", "{{coverName}}"),
            {% endfor %}
            {% for coverSwitchName in device.coverSwitchNames %}
            romasku.coverSwitchPressAction("press_action", "{{coverSwitchName}}"),
            romasku.coverSwitchType("switch_type", "{{coverSwitchName}}"),
            romasku.coverSwitchInvert("cover_invert", "{{coverSwitchName}}"),
            {% if device.coverNames %}
            romasku.coverSwitchCoverIndex("cover_index", "{{coverSwitchName}}", {{device.coverNames | length}}),
            romasku.coverSwitchLocalMode("local_mode", "{{coverSwitchName}}"),
            {% endif %}
            romasku.coverSwitchBindedMode("binded_mode", "{{coverSwitchName}}"),
            romasku.coverSwitchLongPressDuration("long_press_duration", "{{coverSwitchName}}"),
            {% endfor %}
        ],
        meta: { multiEndpoint: true },
        configure: async (device, coordinatorEndpoint, logger) => {
            {% for switchName in device.switchNames %}
            const endpoint{{loop.index}} = device.getEndpoint({{loop.index}});
            await reporting.bind(endpoint{{loop.index}}, coordinatorEndpoint, ["genMultistateInput"]);
            // switch action:
            await endpoint{{loop.index}}.configureReporting("genMultistateInput", [
                {
                    attribute: {ID: 0x0055 /* presentValue */, type: 0x21}, // uint16
                    minimumReportInterval: 0,
                    maximumReportInterval: constants.repInterval.MAX,
                    reportableChange: 1,
                },
            ]);
            {% endfor %}
            {% for relayName in device.relayNames %}
            const endpoint{{loop.index  + (device.switchNames | length)}} = device.getEndpoint({{loop.index  + (device.switchNames | length)}});
            await reporting.onOff(endpoint{{loop.index  + (device.switchNames | length)}}, {
                min: 0,
                max: constants.repInterval.MAX,
                change: 1,
            });
            {% endfor %}

            {% for relayName in device.relayIndicatorNames %}
            await endpoint{{loop.index  + (device.switchNames | length)}}.configureReporting("genOnOff", [
                {
                    attribute: {ID: 0xff02, type: 0x10}, // Boolean
                    minimumReportInterval: 0,
                    maximumReportInterval: constants.repInterval.MAX,
                    reportableChange: 1,
                },
            ]);
            {% endfor %}

            {% for coverSwitchName in device.coverSwitchNames %}
            const coverSwitch{{loop.index}} = device.getEndpoint({{loop.index + (device.switchNames | length) + (device.relayNames | length)}});
            await reporting.bind(coverSwitch{{loop.index}}, coordinatorEndpoint, ["genMultistateInput"]);
            await coverSwitch{{loop.index}}.configureReporting("genMultistateInput", [
                {
                    attribute: "presentValue",
                    minimumReportInterval: 0,
                    maximumReportInterval: constants.repInterval.MAX,
                    reportableChange: 1,
                },
            ]);
            {% endfor %}

            {% for coverName in device.coverNames %}
            const cover{{loop.index}} = device.getEndpoint({{loop.index + (device.switchNames | length) + (device.relayNames | length) + (device.coverSwitchNames | length)}});
            await reporting.bind(cover{{loop.index}}, coordinatorEndpoint, ["closuresWindowCovering"]);
            await cover{{loop.index}}.configureReporting("closuresWindowCovering", [
                {
                    attribute: "moving",
                    minimumReportInterval: 0,
                    maximumReportInterval: constants.repInterval.MAX,
                    reportableChange: 1,
                },
            ]);
            {% endfor %}
        },
        {% if z2m_v1 %}
        ota: ota.zigbeeOTA,
        {% else %}
        ota: true,
        {% endif%}
    },
{% endfor %}
];

module.exports = definitions;
